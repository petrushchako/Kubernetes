# Demo:<br>Imperative Deployments and Working with Resources in Your Cluster

In this demo, we explored deploying and managing Kubernetes resources using both imperative and declarative techniques. We focused on deployments, pods, and services, and also looked at how to modify existing resources.

### Imperative Deployment
We began by deploying resources imperatively using the `kubectl create` and `kubectl run` commands.

#### Creating a Deployment Imperatively
```bash
kubectl create deployment hello-world --image=gcr.io/google-samples/hello-app:1.0
```

This command directly instructs Kubernetes to create a deployment named `hello-world` that will run containers based on the `gcr.io/google-samples/hello-app:1.0` image. This action subsequently creates a ReplicaSet and a pod with a single replica.

#### Creating a Bare Pod Imperatively
```bash
kubectl run hello-world-pod --image=gcr.io/google-samples/hello-app:1.0
```

This command directly instructs Kubernetes to run a pod named `hello-world-pod` using the specified image. This pod is not managed by any controller like a Deployment or ReplicaSet.

#### Verifying Deployed Resources
We used `kubectl get pods` to check the status of our deployment and the bare pod. The output showed both pods in a `Running` state.

```
NAME                                READY   STATUS    RESTARTS   AGE
hello-world-5457b44555-gnxsk         1/1     Running   0          14m
hello-world-pod                       1/1     Running   0          13m
```

We also used `kubectl get pods -o wide` to see more details, including the IP addresses assigned to the pods and the nodes they were scheduled on.

```
NAME                                READY   STATUS    RESTARTS   AGE   IP                NODE        NOMINATED NODE   READINESS GATES <none>
hello-world-5457b44555-gnxsk         1/1     Running   0          15m   192.168.206.127   c1-node3    <none>           <none>
hello-world-pod                       1/1     Running   0          14m   192.168.131.62    c1-node2    <none>           <none>
```

#### Examining Containers on a Node
We demonstrated how to SSH into a worker node (`c1-node3` in this case) and use `crictl` (for Containerd runtime) or `docker ps` (for Docker runtime) to view the containers running on that node, including the ones started by Kubernetes.

```bash
sudo crictl --runtime-endpoint unix:///var/run/containerd/containerd.sock ps
```

or

```bash
sudo docker ps
```

The output showed our `hello-app` container running alongside other Kubernetes system containers like `calico-node` and `kube-proxy`.

#### Troubleshooting with `kubectl logs`
The `kubectl logs` command is useful for retrieving logs from a container within a pod.

```bash
kubectl logs hello-world-pod
```

This command displayed the standard output of the `hello-app` container running in the `hello-world-pod`.

#### Interacting with a Running Container using `kubectl exec`

The `kubectl exec` command allows you to run commands inside a container. The `-it` flags provide an interactive terminal.

```bash
kubectl exec -it hello-world-pod -- /bin/sh
```

This command opened a shell session within the `hello-world-pod` container, allowing us to run commands like `hostname` and `ip addr` to inspect the container's environment.
